{% extends "base.html" %}

{% block title %}DCO Awards 2025 - Vote{% endblock %}

{% block content %}
<div class="card">
    <h2>üó≥Ô∏è Cast Your Vote</h2>
    <p>Vote for your favorite team member in the current DCO Awards 2025 category!</p>
    
    <div id="waiting" class="loading" style="display: none;">
        <div class="spinner"></div>
        <h3>Waiting for poll to start...</h3>
        <p>The host will begin the voting session shortly.</p>
    </div>
    
    <div id="voting-section" style="display: none;">
        <div id="current-question" class="question-display">
            <span id="question-text">Loading question...</span>
        </div>
        
        <!-- Timer Section -->
        <div id="timer-section" style="text-align: center; margin: 20px 0;">
            <div id="timer-display" style="font-size: 2em; font-weight: bold; color: #4CAF50; margin-bottom: 10px;">
                30
            </div>
            <div id="timer-bar" style="width: 100%; height: 8px; background: #e0e0e0; border-radius: 4px; overflow: hidden; margin: 0 auto;">
                <div id="timer-progress" style="width: 100%; height: 100%; background: linear-gradient(90deg, #4CAF50 0%, #ff4444 100%); transition: width 1s linear;"></div>
            </div>
        </div>
        
        <div class="vote-options" id="vote-options">
            <!-- Vote options will be populated dynamically -->
        </div>
        
        <div id="vote-status" style="text-align: center; margin: 20px 0; font-weight: bold; color: #4CAF50;">
            <!-- Vote status will be shown here -->
        </div>
        
        <div id="submit-section" style="text-align: center; margin: 20px 0;">
            <button id="submit-vote" class="btn" style="font-size: 1.2em; padding: 15px 30px; display: none; background: #ff6b6b;">
                üó≥Ô∏è Submit Vote
            </button>
        </div>
    </div>
    
    <div id="poll-ended" class="loading" style="display: none;">
        <h3>Poll Ended</h3>
        <p>Thank you for voting! The results are being calculated.</p>
    </div>
</div>

<div class="card">
    <div class="navigation">
        <a href="/admin" target="_blank">Host Controls</a>
        <a href="/">Back to Home</a>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    const socket = io();
    let currentVote = null;
    let isPollingActive = false;
    let currentQuestion = '';

    // DOM elements
    const waitingDiv = document.getElementById('waiting');
    const votingSection = document.getElementById('voting-section');
    const pollEndedDiv = document.getElementById('poll-ended');
    const questionText = document.getElementById('question-text');
    const voteOptions = document.getElementById('vote-options');
    const voteStatus = document.getElementById('vote-status');

    // Current voting options (will be updated from server)
    let currentOptions = [];
    let timerInterval = null;
    let timeLeft = 30;
    let selectedOption = null;
    let hasVoted = false;

    // Socket event handlers
    socket.on('connect', () => {
        console.log('Connected to voting system');
    });

    socket.on('status_update', (data) => {
        isPollingActive = data.is_polling_active || false;
        currentQuestion = data.current_question || '';
        currentOptions = data.current_options || [];
        
        if (isPollingActive && currentQuestion) {
            showVotingInterface();
        } else {
            showWaitingInterface();
        }
    });

    socket.on('poll_started', (data) => {
        isPollingActive = true;
        currentQuestion = data.question;
        currentOptions = data.options || [];
        showVotingInterface();
    });

    socket.on('poll_ended', (data) => {
        isPollingActive = false;
        showPollEndedInterface();
    });

    socket.on('question_changed', (data) => {
        isPollingActive = true;
        currentQuestion = data.question;
        currentOptions = data.options || [];
        currentVote = null;
        showVotingInterface();
    });

    socket.on('all_questions_complete', () => {
        isPollingActive = false;
        showPollEndedInterface();
    });

    function showWaitingInterface() {
        waitingDiv.style.display = 'block';
        votingSection.style.display = 'none';
        pollEndedDiv.style.display = 'none';
    }

    function showVotingInterface() {
        waitingDiv.style.display = 'none';
        votingSection.style.display = 'block';
        pollEndedDiv.style.display = 'none';
        
        // Reset voting state
        selectedOption = null;
        hasVoted = false;
        timeLeft = 30;
        
        // Update question
        questionText.textContent = currentQuestion;
        
        // Generate vote options
        generateVoteOptions();
        
        // Start timer
        startTimer();
        
        // Update vote status
        updateVoteStatus();
    }

    function showPollEndedInterface() {
        waitingDiv.style.display = 'none';
        votingSection.style.display = 'none';
        pollEndedDiv.style.display = 'block';
    }

    function generateVoteOptions() {
        voteOptions.innerHTML = '';
        
        // Use the specific options for the current award
        if (currentOptions && currentOptions.length > 0) {
            currentOptions.forEach(option => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'vote-option';
                optionDiv.textContent = option;
                optionDiv.dataset.member = option;
                
                if (selectedOption === option) {
                    optionDiv.classList.add('selected');
                }
                
                optionDiv.addEventListener('click', () => {
                    selectOption(option);
                });
                
                voteOptions.appendChild(optionDiv);
            });
        } else {
            // Fallback if no options are provided
            voteOptions.innerHTML = '<p>No voting options available for this question.</p>';
        }
    }

    function selectOption(option) {
        if (hasVoted || !isPollingActive) return;
        
        // Update UI
        document.querySelectorAll('.vote-option').forEach(opt => {
            opt.classList.remove('selected');
        });
        
        const selectedOptionDiv = document.querySelector(`[data-member="${option}"]`);
        if (selectedOptionDiv) {
            selectedOptionDiv.classList.add('selected');
        }
        
        selectedOption = option;
        updateVoteStatus();
        
        // Show submit button
        document.getElementById('submit-vote').style.display = 'inline-block';
    }
    
    function startTimer() {
        // Clear any existing timer
        if (timerInterval) {
            clearInterval(timerInterval);
        }
        
        timeLeft = 30;
        updateTimerDisplay();
        
        timerInterval = setInterval(() => {
            timeLeft--;
            updateTimerDisplay();
            
            if (timeLeft <= 0) {
                clearInterval(timerInterval);
                // Auto-submit if user has selected an option
                if (selectedOption && !hasVoted) {
                    submitVote();
                } else {
                    // Time's up, disable voting
                    disableVoting();
                }
            }
        }, 1000);
    }
    
    function updateTimerDisplay() {
        const timerDisplay = document.getElementById('timer-display');
        const timerProgress = document.getElementById('timer-progress');
        
        timerDisplay.textContent = timeLeft;
        
        // Update progress bar
        const progress = (timeLeft / 30) * 100;
        timerProgress.style.width = progress + '%';
        
        // Change color as time runs out
        if (timeLeft <= 10) {
            timerDisplay.style.color = '#ff4444';
            timerProgress.style.background = '#ff4444';
        } else if (timeLeft <= 20) {
            timerDisplay.style.color = '#ff8800';
            timerProgress.style.background = 'linear-gradient(90deg, #ff8800 0%, #ff4444 100%)';
        } else {
            timerDisplay.style.color = '#4CAF50';
            timerProgress.style.background = 'linear-gradient(90deg, #4CAF50 0%, #ff4444 100%)';
        }
    }
    
    function submitVote() {
        if (!selectedOption || hasVoted || !isPollingActive) return;
        
        // Send vote to server
        socket.emit('vote', { choice: selectedOption });
        hasVoted = true;
        currentVote = selectedOption;
        
        // Update UI
        document.getElementById('submit-vote').style.display = 'none';
        updateVoteStatus();
        
        // Clear timer
        if (timerInterval) {
            clearInterval(timerInterval);
        }
    }
    
    function disableVoting() {
        // Disable all vote options
        document.querySelectorAll('.vote-option').forEach(option => {
            option.style.opacity = '0.5';
            option.style.pointerEvents = 'none';
        });
        
        // Hide submit button
        document.getElementById('submit-vote').style.display = 'none';
        
        // Update status
        voteStatus.textContent = 'Time\'s up! Voting has ended.';
        voteStatus.style.color = '#ff4444';
    }

    function updateVoteStatus() {
        if (hasVoted && currentVote) {
            voteStatus.textContent = `‚úÖ You voted for: ${currentVote}`;
            voteStatus.style.color = '#4CAF50';
        } else if (selectedOption) {
            voteStatus.textContent = `Selected: ${selectedOption} - Click Submit to vote`;
            voteStatus.style.color = '#ff8800';
        } else {
            voteStatus.textContent = 'Click on a name to select your vote';
            voteStatus.style.color = '#666';
        }
    }
    
    // Add submit button event listener
    document.addEventListener('DOMContentLoaded', function() {
        document.getElementById('submit-vote').addEventListener('click', submitVote);
    });

    // Initialize
    showWaitingInterface();
</script>
{% endblock %}

